
# 토비의 스프링 4장 - 예외

---

## 문제 상황

자바의 예외는 크게 두 가지로 나뉜다.

- **Checked Exception** : 반드시 `throws` 선언이나 `try-catch`로 처리해야 함
- **Unchecked Exception(RuntimeException)** : 명시적 처리를 강제하지 않음

DB 접근 예제를 살펴보자.

```java
try {
    Connection conn = dataSource.getConnection();
    PreparedStatement ps = conn.prepareStatement(sql);
    ResultSet rs = ps.executeQuery();
    // 데이터 처리
    rs.close();
    ps.close();
    conn.close();
} catch (SQLException e) {
    // 예외 처리
}
```

- `SQLException`은 **Checked Exception**이므로 반드시 처리해야 한다.  
- 하지만 `SQLException`은 너무 범용적이라, 원인과 의미를 구분하기 어렵다.  
- 계층적으로 설계된 비즈니스 로직과 결합하기 힘들다.

---

## 예외 전환 (Exception Translation)

스프링은 예외를 **의미 있는 예외 계층 구조**로 변환하여 처리한다.  
즉, **낮은 수준의 기술 예외 → 추상화된 예외**로 전환한다.

### 1. 직접 예외 전환
```java
try {
    // JDBC 실행
} catch (SQLException e) {
    throw new DataAccessException(e); // 추상화된 예외로 변환
}
```

### 2. 런타임 예외 전환
스프링은 Checked Exception을 RuntimeException 계열로 전환한다.  
→ 클라이언트 코드에서 불필요한 `throws` 선언을 제거하고, 필요한 경우에만 잡아 처리할 수 있게 한다.

---

## 스프링의 예외 추상화

스프링은 `DataAccessException`이라는 **계층형 예외 클래스 구조**를 제공한다.

예시 계층:
- `DataAccessException` (루트)
  - `DuplicateKeyException`
  - `DataIntegrityViolationException`
  - `EmptyResultDataAccessException`
  - …

```java
try {
    jdbcTemplate.update("INSERT INTO users(id, name) VALUES(?, ?)", id, name);
} catch (DuplicateKeyException e) {
    // Key 중복에 대한 의미 있는 처리
}
```

- `SQLException`이라는 구체적이고 범용적인 예외 대신,  
- **비즈니스적으로 해석 가능한 예외**(`DuplicateKeyException`)로 변환된다.

---

## 예외 처리 전략

1. **예외 복구 (Recovery)**
   - 예외 상황에서 유효한 대안 로직 수행
   - 예: 네트워크 오류 시 재시도

2. **예외 처리 회피 (Propagation)**
   - 호출한 쪽에 예외를 그대로 던짐
   - 스프링에서는 주로 `RuntimeException`으로 전환해 위임

3. **예외 전환 (Translation)**
   - 의미 없는 예외 → 의미 있는 예외로 변환
   - 기술 예외를 추상화하여 비즈니스 계층에 전달

---

## 정리

- 자바의 `Checked Exception`은 지나친 의존성과 복잡성을 유발한다.  
- 스프링은 예외를 **런타임 예외로 전환**하고, **일관된 추상화 계층**을 제공한다.  
- `DataAccessException`을 통해 DB 예외를 의미 있게 다룰 수 있다.  
- 예외 처리의 세 가지 방식: **복구, 회피, 전환**  
- 결국 목표는 **비즈니스 로직과 기술 로직의 분리, 유지보수성 향상**이다.
